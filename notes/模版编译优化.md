# 靶向更新

## 更新类型标记
[更新类型标记](https://cn.vuejs.org/guide/extras/rendering-mechanism.html#patch-flags)
对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息：
```
<!-- 仅含 class 绑定 -->
<div :class="{ active }"></div>

<!-- 仅含 id 和 value 绑定 -->
<input :id="id" :value="value">

<!-- 仅含文本子节点 -->
<div>{{ dynamic }}</div>
```
[在编译模版中查看](https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2IDpjbGFzcz1cInsgYWN0aXZlIH1cIj48L2Rpdj5cblxuPGlucHV0IDppZD1cImlkXCIgOnZhbHVlPVwidmFsdWVcIj5cblxuPGRpdj57eyBkeW5hbWljIH19PC9kaXY+Iiwib3B0aW9ucyI6e319)
在为这些元素生成渲染函数时，Vue 在 vnode 创建调用中直接编码了每个元素所需的更新类型：
```
createElementVNode("div", {
  class: _normalizeClass({ active: _ctx.active })
}, null, 2 /* CLASS */)
```
最后这个参数 2 就是一个更新类型标记 (patch flag)。一个元素可以有多个更新类型标记，会被合并成一个数字。运行时渲染器也将会使用位运算来检查这些标记，确定相应的更新操作：
```
if (vnode.patchFlag & PatchFlags.CLASS /* 2 */) {
  // 更新节点的 CSS class
}
```
位运算检查是非常快的。通过这样的更新类型标记，Vue 能够在更新带有动态绑定的元素时做最少的操作。

Vue 也为 vnode 的子节点标记了类型。举例来说，包含多个根节点的模板被表示为一个片段 (fragment)，大多数情况下，我们可以确定其顺序是永远不变的，所以这部分信息就可以提供给运行时作为一个更新类型标记。
```
export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* children */
  ], 64 /* STABLE_FRAGMENT */))
}
```
运行时会完全跳过对这个根片段中子元素顺序的重新协调过程。



## BlockTree
> 为什么我们还要提出 blockTree 的概念？只有 block 不就挺好的么？问题出在 block 在收集动态节点时是忽略虚拟 DOM 树层级的。
```
<div>
  <p v-if="flag">
    <span>{{ name }}</span>
  </p>
  <div v-else>
    <span>{{ name }}</span>
  </div>
</div>
```

> 这里我们知道默认根节点是一个 block 节点，如果要是按照之前的套路来搞，这时候切换flag的状态将无法从p标签切换到 div 标签。   
> **解决方案：就是将不稳定的结构也作为 block 来进行处理。**   
> 针对v-if分支和每个v-for片段，我们就可以将模板划分为<嵌套块>，在每个块内，节点结构将是稳定的

### 不稳定结构
> 所谓的不稳结构就是 DOM 树的结构可能会发生变化。   
> **不稳定结构有哪些呢？ （v-if/else、v-for、Fragment)**

- v-if
```
<div>
  <p v-if="flag">
    <span>{{ name }}</span>
  </p>
  <div v-else>
    <span>{{ name }}</span>
  </div>
</div>
```
编译后的结果：
```
import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    (_ctx.flag)
      ? (_openBlock(), _createElementBlock("p", { key: 0 }, [
          _createElementVNode("span", null, _toDisplayString(_ctx.name), 1 /* TEXT */)
        ]))
      : (_openBlock(), _createElementBlock("div", { key: 1 }, [
          _createElementVNode("span", null, _toDisplayString(_ctx.name), 1 /* TEXT */)
        ]))
  ]))
}
// Check the console for the AST
```
```
Block(div)
    Block(div, { key: 0 })
    Block(p, { key: 1 })
```
> 父节点除了会收集动态节点之外，也会收集子 block。更新时因 key 值不同会进行删除重新创建

- v-for
> 随着v-for变量的变化也会导致虚拟DOM树变得不稳定。
> 如果v-for导致DOM树变得不稳定，就不会收集不稳定的节点。
> 但如果是稳定的Fragment，
```
<div>
  <div v-for="item in arrs">{{item}}</div>
</div>
```
编译后的结果：
```
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.arrs, (item) => {
      return (_openBlock(), _createElementBlock("div", null, _toDisplayString(item), 1 /* TEXT */))
    }), 256 /* UNKEYED_FRAGMENT */))
  ]))
}
```
- _openBlock(true)：表示该节点不会被父节点收集，i.e.不会作为动态节点处理。
> 可以试想一下，如果不增加这个 block，前后元素不一致是无法做到靶向更新的。
> 因为dynamicChildren 中还有可能有其他层级的元素。
> 同时这里还生成了一个 Fragment，因为前后元素个数不一致，所以称之为不稳定序列。

### 稳定Fragment
这里是可以靶向更新的，因为稳定则有参照物。
```
<div>
  <div v-for="item in 3">{{item}}</div>
</div>
```
编译后结果：
```
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    (_openBlock(), _createElementBlock(_Fragment, null, _renderList(3, (item) => {
      return _createElementVNode("div", null, _toDisplayString(item), 1 /* TEXT */)
    }), 64 /* STABLE_FRAGMENT */))
  ]))
}

// Check the console for the AST
```

> ****v-if、v-for为了解决不稳定问题，都会产生一个block。如果子节点不稳定，那么不收集子节点。如果子节点稳定，那么这个block会收集子节点，将子节点放到自己的dynamicChildren上。****

## 静态提升
```
<div>
  <span>hello</span>
  <span a="1" b="2">{{name}}</span>
  <a><span>{{age}}</span></a>
</div>
```
> 我们把模板直接转化成 render 函数是这个酱紫的，那么问题就是每次调用 render 函数都要重创建虚拟节点。   
> `<span>hello</span>` 是完全静态的，没有必要在重新渲染时再次创建和比对它们。
> Vue 编译器自动地会提升这部分 vnode 创建函数到这个模板的渲染函数之外，并在每次渲染时都使用这份相同的 vnode，渲染器知道新旧 vnode 在这部分是完全相同的，所以会完全跳过对它们的差异比对。
```
import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    _createElementVNode("span", null, "hello"),
    _createElementVNode("span", {
      a: "1",
      b: "2"
    }, _toDisplayString(_ctx.name), 1 /* TEXT */),
    _createElementVNode("a", null, [
      _createElementVNode("span", null, _toDisplayString(_ctx.age), 1 /* TEXT */)
    ])
  ]))
}

// Check the console for the AST
```
hoistStatic 之后如下，将不会变化的结构作为常量进行提升。
```
import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

const _hoisted_1 = /*#__PURE__*/_createElementVNode("span", null, "hello", -1 /* HOISTED */)
const _hoisted_2 = {
  a: "1",
  b: "2"
}

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    _hoisted_1,
    _createElementVNode("span", _hoisted_2, _toDisplayString(_ctx.name), 1 /* TEXT */),
    _createElementVNode("a", null, [
      _createElementVNode("span", null, _toDisplayString(_ctx.age), 1 /* TEXT */)
    ])
  ]))
}

// Check the console for the AST
```
> 静态提升是将静态的节点或者属性提升出去。**静态提升是以树为单位。**也就是说树中节点有动态的不会提升。


## 预字符串化
当有足够多连续的静态元素时，它们还会再被压缩为一个“静态 vnode”，其中包含的是这些节点相应的纯 HTML 字符串。 

这些静态节点会直接通过 `innerHTML` 来挂载。同时还会在初次挂载后缓存相应的 DOM 节点。

如果这部分内容在应用中其他地方被重用，那么将会使用原生的 `cloneNode()` 方法来克隆新的 DOM 节点，这会非常高效。

```
<div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div>{{ dynamic }}</div>
</div>
```
编译后：
```
import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

const _hoisted_1 = /*#__PURE__*/_createStaticVNode("<div class=\"foo\">foo</div><div class=\"foo\">foo</div><div class=\"foo\">foo</div><div class=\"foo\">foo</div><div class=\"foo\">foo</div>", 5)

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    _hoisted_1,
    _createElementVNode("div", null, _toDisplayString(_ctx.dynamic), 1 /* TEXT */)
  ]))
}

// Check the console for the AST
```



